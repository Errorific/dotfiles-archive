#+TITLE: Emacs Configuration
#+AUTHOR: Christopher Mckay
#+EMAIL: chris@error.cm

#+NAME: Note
#+BEGIN_SRC emacs-lisp
  ;;; ------------------------------------------
  ;;; Do not edit this file. It was tangled from
  ;;; an org file.
  ;;; ------------------------------------------
#+END_SRC

* Package Management with Pallet
  [[https://github.com/rdallasgray/pallet][Pallet]] is a wonderful little tool built on [[https://github.com/cask/cask][Cask]], a dependency management tool
  for Emacs packages. Pallet adds automatic updating of the =Caskfile= when
  packages are installed and deleted.

** Installing Cask
   Just run this command in your terminal of choice:

   #+NAME: Cask Installation
   #+BEGIN_SRC sh
     $ curl -fsSkL https://raw.github.com/cask/cask/master/go | python
   #+END_SRC

   then add =~/.cask/bin= to your =PATH= so that you can use =cask=.

** Creating a Caskfile
   For now, we just need a minimal =Cask= to get Pallet set up. Mine looks
   like this:

   #+NAME: Cask
   #+BEGIN_SRC emacs-lisp :tangle no
     (source gnu)
     (source melpa)

     (depends-on "pallet")
     (depends-on "req-package")
     (depends-on "evil")
     (depends-on "org")
   #+END_SRC

   Then run the following command in your =.emacs.d= directory to set up Pallet:

   #+NAME: Cask Initialization
   #+BEGIN_SRC sh
     cask install
   #+END_SRC

** Initialize Cask
   Finally, we add the following lines to our init file:

   #+BEGIN_SRC emacs-lisp :tangle no
     (require 'cask "/usr/local/Cellar/cask/0.6.0/cask.el")
     (cask-initialize)
   #+END_SRC

* Dependency Management with =req-package=
  [[https://github.com/edvorg/req-package][req-package]] is a wrapper on top of [[https://github.com/jwiegley/use-package][use-package]], a package dependency
  management tool. The documentation for =use-package= is immensely helpful for
  figuring out how to describe package dependencies and settings. =req-package=
  adds the =:require= keyword which allows us to define dependencies between
  related packages.
** Initialize =req-package=
   With the preceding process complete, we just need to add the following line
   to our init file to begin using =req-package=:

   #+BEGIN_SRC emacs-lisp
     (require 'req-package)
     (setq custom-file "~/.emacs.d/custom.el")
     (load custom-file)
   #+END_SRC

* Keybindings with =bind-key=
  There are a number of ways to bind keys in Emacs, but I find
  =bind-key=, bundled with =use-package=, easier to work with and,
  more importantly, easier to read. =bind-key= takes a key sequence, a
  command, and an optional keymap.  =bind-key*= overrides any minor
  mode which sets the keybinding. =unbind-key= takes a key sequence
  and a keymap and removes that binding. Invoking
  =describe-personal-keybindings= prints a summary of your keybindings
  through =bind-key= and any overrides or conflicts. This is really
  the killer convenience of using =bind-key=.

* Evil
  I was a diehard Vim user for a long time, and I still prefer the Vim way of
  interacting with text. [[https://gitorious.org/evil/pages/Home][Evil]] is a (mostly feature-complete) Vim emulation mode
  for Emacs. It has sane defaults and I rarely find weirdness or lacking
  features.

** =evil=
   Here we have our first package with dependencies. Historically, I've had
   little annoyances when =evil= loads before =evil-leader=, so we'll make sure
   it gets loaded first. By default, =evil= uses its own cursor which shows up
   black regardless of face settings. Setting =evil-default-cursor= lets us use
   the cursor we're used to. I also redefine a couple of =ex= commands for
   convenience.

   #+BEGIN_SRC emacs-lisp
     (req-package evil
       :require (undo-tree ace-jump-mode)
       :ensure evil
       :init
       (progn
         (setq evil-default-cursor t)
         (evil-mode 1)
         (setq evil-motion-state-modes
               (append evil-emacs-state-modes evil-motion-state-modes))
         (setq evil-emacs-state-modes
           '(magit-mode
             magit-commit-mode
             magit-log-mode
             magit-status-mode
             magit-stash-mode
             git-status-mode
             grep-mode
             dired-mode)))
       :config
       (progn
         (bind-key "[escape]" 'keyboard-escape-quit evil-normal-state-map)
         (bind-key "[escape]" 'keyboard-escape-quit evil-visual-state-map)
         (bind-key "<escape>" 'keyboard-escape-quit)
         (bind-key "\"" 'ace-jump-mode evil-normal-state-map)
         (evil-define-key 'normal
                          tern-mode-keymap "gd" 'tern-find-definition)))
   #+END_SRC

*** =evil-leader=
    =<leader>= is a really useful shorthand in Vim, and [[https://github.com/cofi/evil-leader][evil-leader]] brings the
    same facility to Evil. For really common commands, leader bindings can save
    those precious keystrokes.

    #+BEGIN_SRC emacs-lisp
      (req-package evil-leader
                   :require (evil evil-nerd-commenter)
                   :ensure evil-leader
                   :init
                   (progn
                     (evil-leader/set-leader "<SPC>")
                     (global-evil-leader-mode 1)
                     (evil-leader/set-key
                       "a" 'projectile-ag
                       "l" 'org-insert-link
                       "o" 'other-window
                       "d" 'delete-window
                       "D" 'delete-other-windows
                       "h" 'split-window-below
                       "v" 'split-window-right
                       "k" 'kill-buffer
                       "K" 'kill-buffer-and-window
                       "f" 'dired
                       "c" 'evilnc-comment-or-uncomment-lines
                       "gs" 'magit-status)
                     (evil-leader/set-key-for-mode 'haskell-mode
                       "?" 'ghc-display-errors)))
    #+END_SRC

*** =evil-numbers=
    One of the little Vim conveniences not found in vanilla Evil is incrementing
    and decrementing numbers with =C-a= and =C-x=, respectively, likely because
    these are already important bindings in Emacs. However, by limiting the
    effect to normal mode, we can use [[https://github.com/cofi/evil-numbers][evil-numbers]] to bring this functionality
    back without stomping all over existing bindings. I've removed those 2
    bindings because they are annoying me.

    #+BEGIN_SRC emacs-lisp
      (req-package evil-numbers
                   :require evil)
    #+END_SRC

    #+BEGIN_SRC emacs-list :tangle no
    :config
    (progn
      (bind-key "C-a" 'evil-numbers/inc-at-pt evil-normal-state-map)
      (bind-key "C-x" 'evil-numbers/dec-at-pt evil-normal-state-map)))
    #+END_SRC

*** =evil-surround=
    Working with delimiter pairs is common enough that Tim Pope wrote a plugin
    to ease working with them in Vim, called [[https://github.com/tpope/vim-surround][vim-surround]]. [[https://github.com/timcharper/evil-surround][evil-surround]]
    emulates this functionality in =evil=. It's quite extensible, but the
    defaults seem to cover all my needs. Check out the README for some examples.

    #+BEGIN_SRC emacs-lisp
      (req-package evil-surround
                   :require evil
                   :init (global-evil-surround-mode 1))
    #+END_SRC
*** =evil-matchit=
    Allows you to use % to jump between matched tags in html etc instead of
    just matched delimters

    #+BEGIN_SRC emacs-lisp
      (req-package evil-matchit
                   :require (evil tt-mode)
                   :init (global-evil-matchit-mode 1)
                   :config (
                     plist-put evilmi-plugins 'tt-mode '(
                       (evilmi-simple-get-tag evilmi-simple-jump)
                       (evilmi-html-get-tag evilmi-html-jump))))
    #+END_SRC

*** =undo-tree=
    Standard Emacs undo is kind of confusing. [[http://www.dr-qubit.org/emacs.php#undo-tree][undo-tree]] replaces this with a
    simpler tree structure. It also allows us to visualize the tree directly.

    #+BEGIN_SRC emacs-lisp
      (req-package undo-tree
                   :diminish ""
                   :init
                   (progn
                     (setq undo-tree-auto-save-history t)
                     (global-undo-tree-mode)
                     (setq undo-tree-history-directory-alist
                       (quote (("." . "~/.emacs.d/undo/"))))))
    #+END_SRC

*** =ace-jump-mode=
    #+BEGIN_SRC emacs-lisp
      (req-package ace-jump-mode)
    #+END_SRC

*** =evil-nerd-commenter=
    #+BEGIN_SRC emacs-lisp
      (req-package evil-nerd-commenter
        :require evil)
    #+END_SRC

* Projectile
  Projectile gives a nice way of navigating projects, and finding files, and
  all kinds of things

** =projectile=
   #+BEGIN_SRC emacs-lisp
     (req-package projectile
        :init (projectile-global-mode))
   #+END_SRC

* Org
  #+BEGIN_SRC emacs-lisp
    (req-package org
      :config
      (progn
        (add-hook 'org-mode-hook
                  '(lambda ()
                     (setq mode-name " ꙮ ")))
        (bind-key* "C-c c" 'org-capture)
        (bind-key* "C-c l" 'org-store-link)
        (bind-key* "C-c a" 'org-agenda)
        (bind-key* "C-c b" 'org-iswitch)))
  #+END_SRC

* UI
  I'm pretty picky about how I want my editor to look, so there's a fair bit of
  configuration that goes here.

** flxIdo
   Ido has turned out to be pretty awesome, but it gets significantly better
   with fuzzy matching

   #+BEGIN_SRC emacs-lisp
     (req-package flx-ido
        :require flx
        :init (progn
          (ido-mode 1)
          (ido-everywhere 1)
          (flx-ido-mode 1)))
   #+END_SRC

** Modeline
   Powerline is very popular in Vim (and with Evil users), but I much prefer
   [[https://github.com/Bruce-Connor/smart-mode-line][smart-mode-line]]. It's compatible with just about anything you can imagine,
   and it's easy to set up.


*** =smart-mode-line=
    #+BEGIN_SRC emacs-lisp
      (req-package smart-mode-line
         :init (progn
           (setq sml/shorten-directory t)
           (setq sml/shorten-modes t)
           (sml/setup)))
    #+END_SRC

*** =powerline=
    #+BEGIN_SRC emacs-lisp :tangle no
      (req-package powerline)
    #+END_SRC

** Theme
   I've switched entirely to dark themes to make working with
   Structured Haskell Mode easier.

   I also advise =load-theme= to fully unload the previous theme
   before loading a new one.

   #+BEGIN_SRC emacs-lisp
     (defadvice load-theme
       (before theme-dont-propagate activate)
       (mapc #'disable-theme custom-enabled-themes))

     (req-package color-theme-sanityinc-tomorrow
       :init (load-theme 'sanityinc-tomorrow-eighties :no-confirm))
   #+END_SRC

** Faces
   #+BEGIN_SRC emacs-lisp
     (req-package faces
                  :config
                  (progn
                    (set-face-attribute 'default nil :family "Source Code Pro")
                    (set-face-attribute 'default nil :height 100)))
   #+END_SRC

** Cleanup
   Who wants all that toolbars and scrollbars noise?

   #+BEGIN_SRC emacs-lisp
     (req-package scroll-bar
                  :config
                  (scroll-bar-mode -1))

     (req-package tool-bar
                  :config
                  (tool-bar-mode -1))

     (req-package menu-bar
                  :config
                  (menu-bar-mode -1))
   #+END_SRC

   I also use [[http://www.emacswiki.org/emacs/DiminishedModes][diminish]] to clean up the modeline.

   #+BEGIN_SRC emacs-lisp
     (req-package diminish)

     (req-package server
                  :diminish (server-buffer-clients . ""))
   #+END_SRC

* IDE
  A few conveniences that I like to have in all my =prog-mode= buffers.

** Flycheck
   Flycheck has helped me write more programs than I'm totally
   comfortable admitting.

   #+BEGIN_SRC emacs-lisp
     (req-package flycheck
       :diminish (global-flycheck-mode . " ✓ ")
       :config (progn
         (add-hook 'after-init-hook 'global-flycheck-mode)))
   #+END_SRC

** Magit
   The only git wrapper that matters.

   #+BEGIN_SRC emacs-lisp
     (req-package magit
       :diminish magit-auto-revert-mode)
   #+END_SRC

** Line Numbers
   #+BEGIN_SRC emacs-lisp
     (req-package linum
       :config (progn
         (add-hook 'html-mode-hook
                   '(lambda () (linum-mode 1)))
         (add-hook 'tt-mode-hook
                   '(lambda () (linum-mode 1)))
         (add-hook 'cperl-mode-hook
                   '(lambda () (linum-mode 1)))
         (add-hook 'prog-mode-hook
                   '(lambda () (linum-mode 1))
                   '(lambda () (column-number-mode 1)))
         (defun nolinum () (linum-mode 0))
         (add-hook 'org-mode-hook 'nolinum)
         (add-hook 'project-explorer-mode-hook 'nolinum)
         (add-hook 'term-mode-hook 'nolinum)
         (add-hook 'magit-mode-hook 'nolinum)))
   #+END_SRC

*** Relative Line Numbers
    I was a little spoiled by this feature in Vim, and not having it
    just doesn't sit well with me.

    #+BEGIN_SRC emacs-lisp :tangle no
      (req-package linum-relative
        :init (setq linum-relative-current-symbol ""))
    #+END_SRC

** Delimiters
   I like my delimiters matched and visually distinct. I used [[https://bitbucket.org/kovisoft/paredit][paredit]] for a
   long time, but I'm currently experimenting with [[https://github.com/Fuco1/smartparens][smartparens]]. As for the
   visual element, I quite like [[https://github.com/jlr/rainbow-delimiters][rainbow-delimiters]].

   #+BEGIN_SRC emacs-lisp
     (req-package smartparens-config
       :ensure smartparens
       :diminish (smartparens-mode . "()")
       :init (smartparens-global-mode t))

     (req-package rainbow-delimiters
       :config
       (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
   #+END_SRC

** Colors
   I've had to work with colors in a fair bit of code, so having them displayed
   in buffer is convenient.

   #+BEGIN_SRC emacs-lisp
     (req-package rainbow-mode
       :diminish (rainbow-mode . "")
       :config (add-hook 'prog-mode-hook 'rainbow-mode))
   #+END_SRC

   There's also an interesting mode for uniquely coloring identifiers in code
   so that they are easy to scan for. It's still a bit iffy, but it's fun to
   try.

   #+BEGIN_SRC emacs-lisp
     (req-package color-identifiers-mode
       :diminish (color-identifiers-mode . "")
       :init
       (setq color-identifiers:num-colors 50)
       :config
       (progn
         (add-hook 'emacs-lisp-mode-hook 'color-identifiers-mode)
         (add-hook 'ruby-mode-hook 'color-identifiers-mode)))
   #+END_SRC

** Completion
   #+BEGIN_SRC emacs-lisp
     (req-package auto-complete-config
       :require (ac-math)
       :ensure auto-complete
       :init
       (progn
         (ac-config-default)
         (setq ac-auto-start 3))
       :config
       (progn
         (require 'ac-math)))
   #+END_SRC

** Tags
   #+BEGIN_SRC emacs-lisp
     (req-package ggtags)
   #+END_SRC

** Ag
   Support for the ag tool for doing file searching

   #+BEGIN_SRC emacs-lisp
     (req-package ag
       :config (progn
         (setq ag-highlight-search t)
       )
     )
   #+END_SRC

* Behaviour

** Indentation
   Hell is tabs

   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
     (setq tab-width 2) ; or any other preferred value
     (defvaralias 'c-basic-offset 'tab-width)
   #+END_SRC

** UTF8
   #+BEGIN_SRC emacs-lisp
     (setq locale-coding-system 'utf-8)
     (set-terminal-coding-system 'utf-8)
     (set-keyboard-coding-system 'utf-8)
     (set-selection-coding-system 'utf-8)
     (prefer-coding-system 'utf-8)
   #+END_SRC

** Refresh buffers
   Files that change on disk should chage their buffers

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode 1)
   #+END_SRC

   and dired

   #+BEGIN_SRC emacs-lisp
     (setq global-auto-revert-non-file-buffers t)
     (setq auto-revert-verbose nil)
   #+END_SRC

** Whitespaces
   Show trailing and delete them on save

   #+BEGIN_SRC emacs-lisp
     (setq-default show-trailing-whitespace t)
     (add-hook 'before-save-hook 'whitespace-cleanup)
   #+END_SRC

* OSX
  Things that need changing on macs

** Mac keys
   Switch the Cmd and Meta keys

   #+BEGIN_SRC emacs-lisp
     (setq mac-option-key-is-meta nil)
     (setq mac-command-key-is-meta t)
     (setq mac-command-modifier 'meta)
     (setq mac-option-modifier nil)
   #+END_SRC

** Default browser
   Make it match the system setting

   #+BEGIN_SRC emacs-lisp
     (setq browse-url-browser-function 'browse-url-default-macosx-browser)
   #+END_SRC

** Delete to trash
   #+BEGIN_SRC emacs-lisp
     (setq delete-by-moving-to-trash t)
   #+END_SRC

** Transparancy
   #+BEGIN_SRC emacs-lisp
     (set-frame-parameter (selected-frame) 'alpha '(90 75))
     (add-to-list 'default-frame-alist '(alpha 90 75))
   #+END_SRC

** gls
   use GNU ls from brew

   #+BEGIN_SRC emacs-lisp
     (setq insert-directory-program "gls")
   #+END_SRC

* Languages
** Haskell
         (setq haskell-font-lock-symbols 'unicode)
   #+BEGIN_SRC emacs-lisp
     (req-package haskell-mode
       :require (flycheck flycheck-haskell)
       :commands haskell-mode
       :init
       (add-to-list 'auto-mode-alist '("\\.hs$" . haskell-mode))
       (add-to-list 'auto-mode-alist '("\\.lhs$" . literate-haskell-mode))
       :config
       (progn
         (setq warning-suppress-types (append '(stylish-haskell) warning-suppress-types))
         (req-package inf-haskell)
         (req-package hs-lint)
         (bind-key "C-x C-d" nil haskell-mode-map)
         (bind-key "C-c C-z" 'haskell-interactive-switch haskell-mode-map)
         (bind-key "C-c C-l" 'haskell-process-load-file haskell-mode-map)
         (bind-key "C-c C-b" 'haskell-interactive-switch haskell-mode-map)
         (bind-key "C-c C-t" 'haskell-process-do-type haskell-mode-map)
         (bind-key "C-c C-i" 'haskell-process-do-info haskell-mode-map)
         (bind-key "C-c M-." nil haskell-mode-map)
         (bind-key "C-c C-d" nil haskell-mode-map)
         (defun my-haskell-hook ()
           (setq mode-name " λ ")
           (turn-on-haskell-doc)
           (diminish 'haskell-doc-mode "")
           (capitalized-words-mode)
           (diminish 'capitalized-words-mode "")
           (turn-on-eldoc-mode)
           (diminish 'eldoc-mode "")
           (turn-on-haskell-decl-scan)
           (turn-on-haskell-indentation)
           (setq evil-auto-indent nil))
         (setq haskell-literate-default 'tex)
         (setq haskell-stylish-on-save t)
         (setq haskell-tags-on-save t)
         (add-hook 'haskell-mode-hook 'my-haskell-hook)
          ))

     (req-package flycheck-haskell
       :config (add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))
   #+END_SRC
*** Structured Haskell Mode
    Sometimes I think this is awesome, other times I think it is rage inducing.
    Currently we are in the rage inducing part of the cycle.
    #+BEGIN_SRC emacs-lisp :tangle no
      (req-package shm
                   :require haskell-mode
                   :commands structured-haskell-mode
                   :init (add-hook 'haskell-mode-hook
                                   'structured-haskell-mode))
    #+END_SRC

*** ghc-mod
    #+BEGIN_SRC emacs-lisp :tangle no
      (req-package ghc
        :init (add-hook 'haskell-mode-hook (lambda () (ghc-init))))
    #+END_SRC

** Javascript
   #+BEGIN_SRC emacs-lisp
     (req-package tern
       :require tern-auto-complete
       :init
       (progn
         (add-hook 'js-mode-hook
                   (lambda ()
                     (tern-mode t))))
       :config
       (progn
         (tern-ac-setup)))

     (req-package tern-auto-complete)
   #+END_SRC

** Coffeescript
   #+BEGIN_SRC emacs-lisp
     (req-package coffee-mode)
   #+END_SRC

** Scala

   #+BEGIN_SRC emacs-lisp
     (req-package scala-mode2)
   #+END_SRC

** Perl

   #+BEGIN_SRC emacs-lisp
     (req-package cperl-mode
       :config (progn
         (setq cperl-indent-level 2
               cperl-indent-parens-as-block t
               cperl-indent-subs-specially nil
               cperl-continued-statement-offset 2
               cperl-continued-brace-offset 0
               cperl-close-paren-offset -2
               cperl-tabs-always-indent nil
               cperl-sub-keywords '("sub" "method" "func"))
         (add-to-list 'auto-mode-alist '("\\.t$" . perl-mode))
         (defalias 'perl-mode 'cperl-mode)
         (setq cperl-sub-regexp (regexp-opt cperl-sub-keywords))))

     (req-package tt-mode)
   #+END_SRC

** YAML
   It's a real language now...

   #+BEGIN_SRC emacs-lisp
     (req-package yaml-mode
       :require (flycheck)
       :init (add-to-list 'auto-mode-alist '("\\.ya?ml$" . yaml-mode))
     )
   #+END_SRC

* Annoyances
  Fixing a couple of gripes I have with Emacs.

** Startup screen
   wtf is this uneditable bs

   #+BEGIN_SRC emacs-lisp
   (setq inhibit-startup-screen t)
   #+END_SRC

** Exec path
   This makes your emacs exec path match what a shell does from your
   current environment. For various reasons my shell isn't my default
   so this doesn't work, I get around it by hacking together a shortcut
   to emacs that its run under my zsh profile. Most places this is
   block is what you want instead.

   #+BEGIN_SRC emacs-lisp
     (req-package exec-path-from-shell
       :init
       (when (memq window-system '(mac ns))
         (exec-path-from-shell-initialize)))
   #+END_SRC

** Backups and Autosave Files
   These things end up everywhere, so let's stick them all in a temporary
   directory.

   #+BEGIN_SRC emacs-lisp
     (req-package files
       :init
       (progn
         (setq backup-directory-alist
               `((".*" . ,temporary-file-directory)))
         (setq auto-save-file-name-transforms
               `((".*" ,temporary-file-directory t)))))
   #+END_SRC

** Questions
   Keep it short.

   #+BEGIN_SRC emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Customizations
   [[http://www.emacswiki.org/emacs/cus-edit%2B.el][cus-edit+]] is a really handy way to keep your customizations up to
   date, especially if you set your =custom-file=.

   #+BEGIN_SRC emacs-lisp
     (req-package cus-edit+
       :init (customize-toggle-outside-change-updates))
   #+END_SRC
* Fulfill Requirements
  At long last we need only call the following function to send =req-package= on
  its merry way.

  #+BEGIN_SRC emacs-lisp
    (req-package-finish)
  #+END_SRC
